## [LCR 103. 零钱兑换](https://leetcode.cn/problems/gaM7Ch/)

![image-20250506183509453](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250506183509453.png)



```go
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func coinChange(coins []int, amount int) int {
    // dp[i] 表示凑成金额 i 所需的最少硬币数量
    dp := make([]int, amount+1)
    // 凑成0不需要硬币，所以dp[0]初始化为0
    dp[0] = 0
    for i := 1; i <= amount; i++ {
        // 初始化dp[i]为MaxInt，表示无法凑成的数目
        dp[i] = math.MaxInt
        for _, coin := range coins {
            if i >= coin && dp[i-coin] != math.MaxInt {
                // 更新dp[i]为当前值和dp[i-coin]+1中的较小值
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    // 如果dp[amount]还是是MaxInt，说明凑不成该金额，返回-1
    if dp[amount] == math.MaxInt {
        return = -1
    }
    return dp[amount]
}
```



## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

![image-20250506183047525](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250506183047525.png)



```go
func maxSubArray(nums []int) int {
	// 初始化最大和为切片的第一个元素，因为最大和可能就是首元素
	max := nums[0]
	sum := 0
	for _, num := range nums {
		sum += num
		if sum > max {
			// 更新最大和为当前的和
			max = sum
		}
		// 如果当前和小于0，sum不会再使max增加，舍弃
		if sum < 0 {
			sum = 0 // 也相当于重开新的连续数组
		}
	}
	return max
}
```

