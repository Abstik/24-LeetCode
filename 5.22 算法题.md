## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

![image-20250522183251731](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505221832385.png)

```go
//01背包
//书包容量11，价值也是11
//书包占空间和价值等
//看最后 dp[m][n+1] == target

func canPartition(nums []int) bool {
    //数组长度
    m := len(nums)

    sum := 0
    for _,v := range nums{
        sum = sum + v
    }
    if sum % 2 == 1{    //和为奇数直接返回
        return false
    }

    target := sum / 2   //找 和为target的

    //初始化数组，m行，target+1 列
    //m行表示元素的下标，target+1列表示0到target这几个数字
    dp := make([][]int, m)
    for i := range dp{
        dp[i] = make([]int, target + 1)
        dp[i][0] = 0
    }

    for i:=0; i<=target; i++ {
        if i >= nums[0]{
            dp[0][i] = nums[0]
        }else{
            dp[0][i] = 0
        }
    }

    for i:=1; i<m; i++{
        for j:=1; j<=target; j++ {
            if j - nums[i] >= 0{
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[m-1][target] == target
}

func max(x,y int)int{
    if x > y{
        return x
    }
    return y
}
```

## [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/submissions/631723723/)

![image-20250522184923848](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505221849212.png)

```go
//01背包
//装满容量为sum/2的背包的最大价值

func lastStoneWeightII(stones []int) int {
    m := len(stones)
    sum := 0 //石头总重量

    for _,v := range stones{
        sum += v
    }
    n := sum/2

    dp := make([][]int, m)

    for i := range dp{
        dp[i] = make([]int, n + 1)
        dp[i][0] = 0
    }

    for i := 0; i <= n; i ++ {
        if i >= stones[0]{
            dp[0][i] = stones[0]
        }else{
            dp[0][i] = 0
        }
    }

    for i := 1; i < m; i ++ {
        for j := 1; j <= n; j ++ {
            if j >= stones[i]{
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }

    t := sum - dp[m-1][n]
    return t - dp[m-1][n]
}

func max(x,y int)int{
    if x > y{
        return x
    }
    return y
}
```

