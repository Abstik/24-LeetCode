## [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

![image-20250519195524598](../AppData/Roaming/Typora/typora-user-images/image-20250519195524598.png)



```go
func largestSumAfterKNegations(nums []int, K int) int {
	sort.Slice(nums, func(i, j int) bool {
		return math.Abs(float64(nums[i])) > math.Abs(float64(nums[j]))
	}) // 按绝对值大小降序排序

	for i := 0; i < len(nums); i++ {
		if K > 0 && nums[i] < 0 {
			nums[i] = -nums[i] // 负数取反——按绝对值降序
			K--
		}
	}

	// K有剩余且为奇数，说明已无负数，则正数最小绝对值取反
	if K%2 == 1 {
		nums[len(nums)-1] = -nums[len(nums)-1]
	}

	rt := 0
	for i := 0; i < len(nums); i++ {
		rt += nums[i]
	}
	return rt
}
```



## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

![image-20250519200659178](../AppData/Roaming/Typora/typora-user-images/image-20250519200659178.png)



```go
func maxProfit(prices []int) int {
    dp := make([][]int, len(prices))
    for i := 0; i < len(dp); i++ {
        dp[i] = make([]int, 2)
    }
    // dp[i][0]表示在状态i不持有股票的现金，dp[i][1]为持有股票的现金
    dp[0][0], dp[0][1] = 0, -prices[0]
    for i := 1; i < len(prices); i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])
    }
    return dp[len(prices)-1][0]

}
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

