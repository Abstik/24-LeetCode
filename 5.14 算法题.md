## [200. 岛屿数量 ](https://leetcode.cn/problems/number-of-islands/description/?envType=problem-list-v2&envId=depth-first-search)

![image-20250514183230084](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505141832220.png)

```go
//岛屿：水包围陆地 有多少个陆地连续
//是陆地，dfs上下左右方向 - 标记陆地
//递归条件：不可以重复访问，越界，水

var col,row int

func numIslands(grid [][]byte) int {
    col,row = len(grid),len(grid[0])

    cnt := 0 //记录岛屿数量

    //遍历岛屿
    for i:=0; i<col; i++ {
        for j:=0; j<row; j++ {
            if grid[i][j] == '1'{
                dfs(grid,i,j)  //处理这块陆地
                cnt++  //遍历到新的陆地 岛屿数量加一
            }
        }
    }
    return cnt
}

func dfs(grid[][]byte,x,y int){
    //越界、水、标记过 退出
    if x < 0 || x >= col || y < 0 || y >= row || grid[x][y] != '1'{
        return
    }
    grid[x][y] = '2'
    //dfs上下左右
    dfs(grid,x-1,y)
    dfs(grid,x+1,y)
    dfs(grid,x,y-1)
    dfs(grid,x,y+1)
}
```

## [337. 打家劫舍 III ](https://leetcode.cn/problems/house-robber-iii/?envType=problem-list-v2&envId=depth-first-search)

![image-20250514184749705](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505141847824.png)

```go
// 1.偷root，不能偷左右结点，偷左右节点的孩子结点
// 2.不偷root，（不）偷左右结点
type TNode = TreeNode

func rob(root *TreeNode) int {
	//偷root  不偷root
    var dfs func(root *TNode)(int,int)
	dfs = func(root *TNode) (int, int) {
		if root == nil {
			return 0, 0
		}
		left1, left2 := dfs(root.Left)    //左孩子 偷与不偷的最大值
		right1, right2 := dfs(root.Right) //右孩子  偷与不偷的最大值
		//偷root->不偷左右孩子结点  不偷root->偷左右孩子结点或者不偷，取最大
		return root.Val + left2 + right2, max(left1, left2) + max(right1, right2)
	}
	choose, Nchoose := dfs(root)
	return max(choose, Nchoose)
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

