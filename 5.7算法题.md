## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) 

![image-20250507182307685](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250507182307685.png)

```c
int** levelOrder(struct TreeNode* root, int* returnSize,int** returnColumnSizes) {
    //整体思路:创建队列并实现广度优先搜索的思想，通过遍历每一层的树，将每一层的节点入队，并统计层的节点个数，再将队列中的数据导入到结果数组当中，即出队
    /*正确的顺序应该是：
a) 计算当前层节点数(len)
b) 为当前层分配存储空间
c) 处理当前层所有节点
d) 最后才记录该层的节点数和更新层数*/
    int** ans = (int**)malloc(sizeof(int*) * 2000);//为返回的二维数组分配内存空间，最多支持2000层
    *returnColumnSizes = malloc(sizeof(int) * 2000);//为记录每一层节点数量的数组分配内存空间
    *returnSize = 0;//初始化层数计数器为0
    if(root==NULL) return ans;//若树为空，直接返回ans
    struct TreeNode* queue[2000];//模拟队列数组
    int head = 0, tail = 0;//head、tail分别指向队列的头部和尾部
    queue[tail++] = root;// 初始先将根节点入队
    while (head != tail) {// 结束条件为队列为空，即tail==head
        int len = tail - head;//每一次循环，都会将树当前层(可用*returnSize表示)节点全部入队，因此头部
            //到尾部的节点数即为当前层的全部节点
        ans[*returnSize] = malloc(sizeof(int) * len);// 开辟当前层的一维数组空间
        //当前层的节点个数统计完成之后，需要出队，若节点全部出队，队列里存在下
        //一层的全部节点，因此在出队之前，用临时变量start记录之前的head值，移
        // 动head到下一层节点的起始位置（即tail的位置），相当于当前层节点出队，
        int start = head;// start被赋值后变为当前层的头部，head被赋值后变为当前层的尾部，为下一层做准备
        head = tail;
        for (int i = start; i < head; i++) {
            ans[*returnSize][i - start] = queue[i]->val;//逐个访问当前层的节点值
            if (queue[i]->left) queue[tail++] = queue[i]->left;//访问完一个节点后，将此节点的左右孩子入队
            if (queue[i]->right) queue[tail++] = queue[i]->right;
        }
        //这是一个指向整数数组的指针，用于存储每一层的节点数量
        //ans是一个二维数组，如[[1],[2,3],[4,5,6]]，需要*returnColumnSizes告诉调用者每一层有多少元素
        //每次处理完一层，就立即记录该层的节点数，同时递增层数计数器，为下一层做准备
        (*returnColumnSizes)[(*returnSize)++] = len;// *returnColumnSizes赋值，并将层数加1
        //returnColumnSizes 不是给函数内部使用的，它的目的是让函数向调用者传递信息
        //强调:不能把*returnSize的括号去掉，因为(*returnColumnSizes)：先解引用 returnColumnSizes（得到 int* 数组）
        //[...]：再对这个数组进行索引
        //(*returnSize)++：计算索引值（并递增 *returnSize）
        /*   []（数组下标）优先级高于 *（解引用）
             后置 ++ 的优先级高于 *（解引用）  */
    }
    return ans;
}
```

