## [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/submissions/623214686/)

![image-20250417202814211](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504172028585.png)

```C
int cmp(const void* x, const void* y) // 进行升序排序
{
    return *(int*)x - *(int*)y; // 升序
}
int** threeSum(int* nums, int numsSize, int* returnSize,int** returnColumnSizes) 
{
    int** ans = (int**)malloc(sizeof(int*) * 18000); // 定义一个二维数组
    *returnSize = 0;                                // 初始三元组是零个
    if(numsSize < 3)
    {
        *returnSize = 0;
        return ans;
    }
    qsort(nums, numsSize, sizeof(int), cmp);        // 排序

    int n = 0;//三元组的个数

//-1 -1 0 1
    for (int i = 0; i < numsSize - 2; i ++ ) // 遍历数组
    {
        // 三个元素的关系是 x<=y<=z
        // 如果最小的元素大于0  最大的元素大于0  那么和肯定不为0 不向下执行
        if (nums[i] > 0) {
            break;
        }

        //当前元素与前面元素相等
        if(i > 0 && nums[i-1] == nums[i])
        {
            continue;
        }
        // 接下来定义两个数 一个是i的下一个 一个是最后一个
        int mid = i + 1;
        int right = numsSize - 1;

        while (mid < right) 
        {
            int sum = nums[i] + nums[mid] + nums[right];

            if (sum < 0) // 小于0 让mid向后
            {
                mid++;
            } 
            else if (sum > 0) // 符合要求
            {

                right --;
            } 
            else // sum > 0 right向左
            {
                int* arr = malloc(sizeof(int) * 3);//给一个一维数组
                arr[0] = nums[i];
                arr[1] = nums[mid];
                arr[2] = nums[right];
                ans[(*returnSize)++] = arr;//等于一维数组
                //如果该元素使得sum=0 它的上一个等于它 那么重复
                while (mid < right && nums[right] == nums[right - 1]) // 排重 
                {
                    right--;
                }
                while (mid < right && nums[mid] == nums[mid + 1]) // 排重
                {
                    mid ++ ;
                }
                //移动到新元素
                mid++;
                right --;
            }
        }
    }
    //int** returnColumnSizes
    *returnColumnSizes = malloc(sizeof(int) * (*returnSize));
    for(int i = 0; i < *returnSize; i ++ )
    {
        (*returnColumnSizes)[i] = 3;//每组有三个元素
    }
    
    return ans;
}
```

## [1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/submissions/623252534/)

![image-20250417221752773](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504172217907.png)

```C
//利用队列的思想 如果该元素与队尾元素相同那么就让队尾出队 

char* removeDuplicates(char* s) {
    int len = strlen(s);
    char* ret = (char*)malloc(sizeof(char) * len);//新数组 来存储删除后的数据
    int i = 0;
    while(*s != '\0')
    {
        if(i == 0)//新数组中没有元素 直接进入
        {
            ret[i++] = *s;
        }
        else //新数组不为空
        {
            if(*s == ret[i-1])//删除
            {
                i--;
            }
            else 
            {
                ret[i++] = *s;
            }
        }
        s++;
    }
    ret[i] = '\0';
    return ret;
}
```

