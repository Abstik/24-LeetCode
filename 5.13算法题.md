## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) 

![image-20250510215606400](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250510215606400.png) 

```go
func trap(height []int) int {
    stack :=make([]int,len(height))
    ans :=0
    for i:=0;i<len(height);i++ {
        for len(stack)>0&&height[i]>height[stack[len(stack)-1]] {
            down :=stack[len(stack)-1]
            stack =stack[:len(stack)-1]
            if(len(stack)<=0){
                break
            }
            left :=stack[len(stack)-1]
            curwide :=i-left-1
            curhigh :=min(height[i],height[left])-height[down]
            ans+=curhigh*curwide
        }
        stack=append(stack,i)
    }
    return ans
}
```

```c
int trap(int* height, int heightSize) {
    //整体思路:运用单调栈的思想，在栈内存储每个位置的高度，一定要保证栈内至少有两个元素，否则无法获取左边界，遍历数组，直到找到比栈顶元素大的元素，开始计算，用长度和宽度的乘积计算可接的雨水。
    int* stack=calloc(heightSize,sizeof(int));
    int ans=0,top=-1;
    for(int i=0;i<heightSize;i++){
        while(top>=0&&height[i]>height[stack[top]]){//当栈内有元素且当前高度大于栈顶元素
            int down=stack[top--];//弹出栈顶元素，作为底部
            if(top<0){//如果栈内没有元素了，结束循环，保证有左边界
                break;
            }
            int left=stack[top];//获取左边界
            int curwidth=i-left-1;//获取宽度
            int curheight=fmin(height[left],height[i])-height[down];//获取高度
            ans+=curwidth*curheight;//得到雨水数量
        }
        stack[++top]=i;
    }
    return ans;
}
```

