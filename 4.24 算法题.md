## [658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

![image-20250424154856052](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250424154856052.png)



```c
int* findClosestElements(int* arr, int arrSize, int k, int x, int* returnSize)
{
	int dis, aimi = 0; // 用于更新绝对差和目标下标 
	int cnt = 0;
	for (int i = 0; i < arrSize; i ++)
	{
		cnt += abs(arr[i] - x);
		if (i < k - 1) // 窗口大小不足 
		{
			continue;
		}
		if (i == k - 1) // 窗口数首次达到，记录dis为cnt 
		{
			dis = cnt;
		}
		else // 此后如果有新的更接近的数出现，更新aimi和dis 
		{
			if (cnt < dis)
			{
				aimi = i - k + 1; // 起始位置 
				dis = cnt; // 新的最小值 
			}
		}
		cnt -= abs(arr[i - k + 1] - x); // 窗口左端右移 
	}
	int *rt = malloc(sizeof(int) * k);
	*returnSize = k;
	for (int i = 0; i < k; i ++)
	{
		rt[i] = arr[aimi++]; // 记录 
	}
	 
	return rt;
}
```



## [413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/)

![image-20250424155156790](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250424155156790.png)



```c
int numberOfArithmeticSlices(int* nums, int numsSize)
{
	if (numsSize == 1)
	{ // 仅有一个数，不足等差数列 
		return 0;
	}
	
	int d = nums[0] - nums[1]; // 记录可能为公差的 d 
	int cnt = 0, t = 0;
	for (int i = 2; i < numsSize; i ++) // 最短为三个元素，可以从 2 开始遍历 
	{
		if (nums[i - 1] - nums[i] == d) // 如果仍满足d，那么t++ 
		{
			t ++;
		}
		else // 不满足，则更新d，t归零 
		{
			d = nums[i - 1] - nums[i];
			t = 0;
		}
		cnt += t; // 由于数组的特性，满足等差数列的子集合也必然满足等差数列 
	}
	return cnt;
}
```

