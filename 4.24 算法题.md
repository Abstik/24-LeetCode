## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/submissions/624976555/)

![image-20250423212712507](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504232127937.png)

```c
typedef struct TreeNode TNode;

//依然用层序遍历的方法 最后反转 -- 对每一层操作
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes) 
{
    int** ret = (int**)malloc(sizeof(int*) * 2000);//返回的数组
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);

    *returnSize = 0;
    if(root == NULL)
    {
        return ret;
    }

    TNode** queue = (TNode**)malloc(sizeof(TNode*) * 2000);//模拟数列 -- 存储结点
    int front = 0;
    int back = 0;

    //头结点入队
    queue[back++] = root;

    while(front < back)
    {
        int len = back - front;//每一层的长度
        int start = front;
        front = back;//从front到back是本层所有数据 记录下来 front指向下一层

        //开辟本层空间
        ret[(*returnSize)] = malloc(sizeof(int) * len);
        for(int i = start; i < front; i ++ )//每一层循环
        {
            //入数组
            ret[*returnSize][i-start] = queue[i]->val;
            //左右孩子入队
            if(queue[i]->left)
            {
                queue[back++] = queue[i]->left;
            }
            if(queue[i]->right)
            {
                queue[back++] = queue[i]->right;
            }
        }
        (*returnColumnSizes)[(*returnSize) ++ ] = len;
    }

    //反转二维数组
    for(int i = 0; i < (*returnSize)/2; i ++ )//每一层
    {
        int* tmp = ret[i];
        ret[i] = ret[(*returnSize) - i - 1];
        ret[(*returnSize) - i - 1] = tmp;

        //再反转个数
        int t = (*returnColumnSizes)[i];
        (*returnColumnSizes)[i] = (*returnColumnSizes)[(*returnSize) - 1 - i];
        (*returnColumnSizes)[(*returnSize) - 1 - i] = t;
    }

    return ret;
}
```

## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

![image-20250423220251663](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504232202009.png)

```C
typedef struct TreeNode TNode;

int highest(TNode* root)
{
    if(root == NULL)
    {
        return 0;
    }
    return (1 + fmax(highest(root->left), highest(root->right)));
}



bool isBalanced(struct TreeNode* root) 
{
    if(root == NULL)
    {
        return true;
    }

    //当前树平衡 且两个子树平衡
    return fabs(highest(root->left) - highest(root->right) ) <= 1 && isBalanced(root->left) && isBalanced(root->right);
}

```

## [116. 填充每个节点的下一个右侧节点指针 ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/submissions/624999935/)

![image-20250423223930240](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504232239651.png)

```C
typedef struct Node TNode;

//直接在原数组进行操作
//记录最左边的结点 从最左边开始遍历

struct Node* connect(struct Node* root) 
{
    if(root == NULL)
    {
        return NULL;
    }

    int capacity = pow(2,12) - 1;
	TNode** queue = (TNode**)malloc(sizeof(TNode*) * capacity);//模拟队列 存储结点
    int front = 0, back = 0;
    
    //根结点入队
    queue[back++] = root;
    while(front < back)
    {
        int len = back - front;//每层长度
        int start = front;
        front = back;

        int i = 0;
        for(i = start; i < front; i ++ )//每一层
        {
            //左右孩子存入
            if(queue[i]->left)
            {
                queue[back++] = queue[i]->left;
            }
            if(queue[i]->right)
            {
                queue[back++] = queue[i]->right;
            }

            if(i == front-1)
            {
                queue[i]->next = NULL;
                continue;
            }
            queue[i]->next = queue[i+1];//连接起来
            
        }
    }
    return root;
}
```

## [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/submissions/625227314/)

![image-20250424183822193](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504241838630.png)

```C
typedef struct TreeNode TNode;

double* averageOfLevels(struct TreeNode* root, int* returnSize) {
    double* ret = (double*)malloc(sizeof(double) * 10000);//返回的数组
    *returnSize = 0;//初始为0;

    if(root == NULL)
    {
        return ret;
    }

    TNode** queue = (TNode**)malloc(sizeof(TNode*) * 10000);//模拟队列
    int front = 0;
    int back = 0;
    queue[back++] = root;//根结点在队尾入队

    while(front < back)
    {
        double sum = 0;
        int len = back - front;//本层结点个数
        int start = front;
        front = back;//下一组
        for(int i = start; i < front; i ++ )
        {
            sum += queue[i]->val;
            //左右孩子入队
            if(queue[i]->left)
            {
                queue[back++] = queue[i]->left;
            }
            if(queue[i]->right)
            {
                queue[back++] = queue[i]->right;
            }
        }
        ret[(*returnSize) ++ ] = sum/1.0/len;
    }
    return ret;
}
```

## [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/submissions/625231181/)

![image-20250424185957062](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504241859427.png)

```C
typedef struct Node Node;

int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) 
{
    *returnSize = 0;
    *returnColumnSizes = (int*)malloc(sizeof(int) * 10000);

    int** ret = (int**)malloc(sizeof(int*) * 10000);
    if(!root)
    {
        return ret;//root为空
    }

    //struct Node** children;

    Node** queue = (Node**)malloc(sizeof(Node*) * 10000);
    int front = 0;
    int back = 0;
    int level = 0;//用来记录第几层
    //头结点入队
    queue[back++] = root;

    while(front < back)
    {
        int len = back - front;
        ret[level] = (int*)malloc(sizeof(int) * len);
        
        int start = front;
        front = back;
        for(int i = start; i < front; i ++ )
        {
            //入数组
            ret[level][i-start] = queue[i]->val;
            for(int j = 0; j < queue[i]->numChildren; j ++ )
            {
                //孩子入队列
                queue[back++] = queue[i]->children[j];
            }
        }
        (*returnColumnSizes)[level++] = len;
    }
    *returnSize = level;
    return ret;   
}
```

