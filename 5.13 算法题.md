## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/submissions/629577687/?envType=problem-list-v2&envId=depth-first-search)

![image-20250513184443847](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505131844948.png)

```go
//没有被包围 -- 是边界或者与边界相连
//与边界相连的不变，不相连的全部变为x

var col, row int

func solve(board [][]byte) {
	col, row = len(board), len(board[0])
	//对边界上的元素 如果有0标记为A
	for i := 0; i < col; i++ { //遍历每一行 -- 第一列和最后一列
		dfs(board, i, 0)
		dfs(board, i, row-1)
	}
	//对边界里面一层的元素
	for j := 1; j < row-1; j++ { //遍历每一列 -- 第一行和最后一行（除了首尾列）
		dfs(board, 0, j)
		dfs(board, col-1, j)
	}

	//修改board
	for i := 0; i < col; i++ {
		for j := 0; j < row; j++ {
			if board[i][j] == 'A' { //被标记成A的0 不能被包围 还是0
				board[i][j] = 'O'
			} else if board[i][j] == 'O' { //没有被标记成A的0  被包围 变成X
				board[i][j] = 'X'
			}
		}
	}
}

// dfs
func dfs(board [][]byte, x, y int) {
	//越界
	if x < 0 || x >= col || y < 0 || y >= row || board[x][y] != 'O' { //不是0返回
		return
	}
	board[x][y] = 'A'
	//如果是‘0’ 对周围的进行标记
	dfs(board, x-1, y)
	dfs(board, x+1, y)
	dfs(board, x, y-1)
	dfs(board, x, y+1)
}
```

