## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

![image-20250421143153686](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250421143153686.png)



```c
int* largestValues(struct TreeNode* root, int* returnSize)
{
	int *rt = (int*)malloc(sizeof(int) * 10010);
	*returnSize = 0;
	struct TreeNode* queue[10010]; //模拟队列 
	if (root == NULL)
	{
		return NULL;
	}
	
	int front = 0, rear = 0, k = 0; // k 记录 returnSize 返回值 
	queue[rear] = root;
	rear++;
	while (front != rear)
	{
		int len = rear - front; // 记录每层几个结点，由上一次父节点确定 
		int max = -INT_MAX - 1; // 初始化最大值 
		while (len > 0)
		{
			struct TreeNode* curr = queue[front];
			front++;
			max = fmax(max, curr->val); // 比较获取最大值 
			// 左右孩子入队 
			if (curr->left != NULL) queue[rear++] = curr->left;
			if (curr->right != NULL) queue[rear++] = curr->right;
			len--;
			if (len == 0) rt[k] = max; // len == 0，说明一层遍历结束，存储入 rt 
		}
		k++; // 层数自增 
	}
	*returnSize = k;
	return rt;
}
```



## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

![image-20250421143717835](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250421143717835.png)



```c
int evalRPN(char** tokens, int tokensSize) {
    int st[tokensSize], top = -1; // 模拟栈 

    for (int i = 0; i < tokensSize; i ++)
	{
		// 长度大于 1，或者每一行首元素在 0 - 9 之间，说明该行存储为数字 
        if (strlen(tokens[i]) > 1 || (tokens[i][0] >= '0' && tokens[i][0] <= '9'))
		{
            ++top;
            st[top] = atoi(tokens[i]); // 利用 atoi 函数转化为数字并入栈 
        }
		else
		{
			// 栈顶两元素出栈运算 
            int num2 = st[top];
            top--;
            int num1 = st[top];
            top--;
            switch (tokens[i][0])
			{
                case '+':
                    ++top;
                    st[top] = num1 + num2;
                    break;
                case '-':
                    ++top;
                    st[top] = num1 - num2;
                    break;
                case '*':
                    ++top;
                    st[top] = num1 * num2;
                    break;
                case '/':
                    ++top;
                    st[top] = num1 / num2;
                    break;
            }
        }
    }
    return st[top];
}
```

