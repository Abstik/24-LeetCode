## [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) 

![image-20250508191347099](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250508191347099.png) 

```c
int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes) {
    //整体思路与102题类似，只是要在最后添加反转数组的操作，有一些细节问题见下
    int **ans=calloc(2000,sizeof(int));
    *returnColumnSizes=calloc(2000,sizeof(int));
    *returnSize=0;
    if(!root) return ans;
    struct TreeNode* queue[2000];
    int head=0,tail=0;
    queue[tail++]=root;
    while(head!=tail){
        int len=tail-head;
        ans[*returnSize]=calloc(len,sizeof(int));
        int start=head;
        head=tail;
        for(int i=start;i<head;i++){
            ans[*returnSize][i-start]=queue[i]->val;
            if(queue[i]->left) queue[tail++]=queue[i]->left;
            if(queue[i]->right) queue[tail++]=queue[i]->right;
        }
        (*returnColumnSizes)[(*returnSize)++]=len;
    }
    for(int i=0;i*2<*returnSize;i++){
        //*returnSize 是总层数，2 * i < *returnSize 等价于 i < *returnSize / 2
        //这样只需要遍历到中间位置，就可以完成整个数组的反转
        //这里需要注意以下几点
        //1.需要同时反转结果数组和存储层节点数的数组，因为这两者同时以指针的形式传送信息给主函数。returnColumnSizes 数组记录了每一层的节点数，必须与 levelOrder 同步交换，保持对应关系
        //2.反转结果数组时中间值以一级指针的形式表示，更加高效
        //3.*returnSize表示层数，例如有5层时[0]和[4]交换，所以[i]和[(*returnSize)-i-1]交换。
        int* tmp1=ans[i];
        ans[i]=ans[(*returnSize)-i-1];
        ans[(*returnSize-i-1)]=tmp1;
        int tmp2=(*returnColumnSizes)[i];
        (*returnColumnSizes)[i]=(*returnColumnSizes)[(*returnSize)-i-1];
        (*returnColumnSizes)[(*returnSize)-i-1]=tmp2;
    }
    return ans;
}
```

