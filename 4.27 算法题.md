## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![image-20250426214559717](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250426214559717.png)



```c
int minSubArrayLen(int target, int* nums, int numsSize)
{
	// 滑动窗口 
	int cnt = 0, left = 0, ans = 1000000;
	// left用于确认左边界，ans作为窗口长度的标准来存储
	/*
	由于对于nums[i]，target和numsSize的约束条件，使得ans=100000亦成立
	所以将ans设置为1000000，避免返回时出错
	*/
	for (int i = 0 ; i < numsSize; i ++)
	{
		cnt += nums[i];
		if (cnt < target) continue; //当窗口值不以满足target，继续扩大 
		while (cnt >= target) // 条件满足，则不断缩小左边界，以获取更小值 
		{
			ans = fmin(ans, i - left + 1);
			cnt -= nums[left++];
		}
	}
	return ans == 1000000 ? 0 : ans; // ans始终没有更改，即没有合理的窗口，返回0 
}
```



## [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)

![image-20250426221445351](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250426221445351.png)



```c
char * removeKdigits(char * num, int k)
{
	// 贪心与栈 
    int len = strlen(num), top = -1;
    /*
	条件范围内，最高位最小，次高位最小，以此类推，得到的必是最小值 
    第i个数字可以占据i-1和i位
	从头往后扫描，依次删除A[i] > A[i+1]的A[i]
	*/
	char *st = malloc(sizeof(char) * (len + 1));
    for(int i = 0; i < len; i ++)
    {
        while(top != -1 && st[top] > num[i] && k > 0) //出栈
        {
            top--;
            k--;
        }
        /*
		着重讨论数字0，比如10010，
		第二位0加入，第一位的1会被删除
		0会到首位，显然0的存在是多余的
		*/
        if(num[i] != '0' || top != -1) // //入栈
        {
        	st[++top] = num[i];
		}
    }
    while(k > 0 && top > -1)
    {
        top--;
        k--;
    }
    if(top == -1) // 栈空，结果为 0 
    {
    	st[++top] = '0';
	}
    st[++top] = '\0'; // 末尾置零 
    
	return st;
}
```

