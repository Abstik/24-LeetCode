## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

![image-20250425200226222](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250425200226222.png)

```c
void preOrder(struct TreeNode* root,int* ret,int* returnSize){
    if(root==NULL) return;//中序遍历顺序：left->middle->right，运用递归遍历的思想
    preOrder(root->left,ret,returnSize);//先递归将左节点值录入
    ret[(*returnSize)++]=root->val;//再将根节点，右节点值录入
    preOrder(root->right,ret,returnSize);
}
int* inorderTraversal(struct TreeNode* root, int* returnSize) {
    int* ret=calloc(100,sizeof(int));//分配内存
    *returnSize=0;//初始化数组大小
    preOrder(root,ret,returnSize);//递归
    return ret;
}
```

## [125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/) 

![image-20250425202736918](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250425202736918.png) 

```c
bool isPalindrome(char* s) {
    int len = strlen(s);//获取数组长度
    int bnt = 0,m,n;
    char a[200001];
    for (int i = 0; i <= len - 1; i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {//将小写字母转移出来
            a[bnt++] = s[i];
        }
        if (s[i] >= 'A' && s[i] <= 'Z') {//将大写字母转移出来并转换为小写字母方便比较
            a[bnt++] = s[i] - 'A' + 'a';
        }
        if (s[i] >= '0' && s[i] <= '9') {//将数字转移出来
            a[bnt++] = s[i];
        }
    }
    a[bnt] = '\0';//结束符号
    for (m = 0, n = bnt - 1; m < n; m++, n--) {
        if (a[m] != a[n])//前后比较，如果不相等返回false
            return false;
    }
    return true;
}
```

