## [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/?envType=problem-list-v2&envId=binary-search)

![image-20250416154817101](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504161548437.png)

```C
int search(int* nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1 ;
    int mid = (left + right) / 2;

    while(left <= right)
    {
        if(nums[mid] > target)
        {
            right = mid - 1;
        }
        else if(nums[mid] == target)
        {
            return mid;
        }
        else //nums[mid] < target
        {
            left = mid + 1;
        }
        mid = (left + right) / 2;
    }

    return -1;
}
```



## [105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=problem-list-v2&envId=binary-tree)

![image-20250416161054314](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504161610663.png)

```C
typedef struct TreeNode TNode;
struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {
    //先序遍历的第一个结点一定是根结点 （一个一个添加父结点）
    //中序遍历根结点前面的结点 是左子树的
    if(inorderSize == 0)//构建完成
    {
        return NULL;
    }

    TNode* root = (TNode*)malloc(sizeof(TNode));
    root->val = preorder[0];
    //根据中序遍历找到左子树
    int i = 0;
    for(i = 0; i < inorderSize; i ++ )
    {
        if(inorder[i] == preorder[0])
        {
            break;
        }
    }
    root->left = buildTree(preorder+1, i, inorder, i);//构建左子树
    root->right = buildTree(preorder+i+1, preorderSize - i - 1, inorder + i + 1, inorderSize - 1 - i);//构建右子树
    return root;
}
```

## [106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/622814269/?envType=problem-list-v2&envId=binary-tree)

![image-20250416161638435](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504161616770.png)

```C
 //同理 后序遍历最后一个数是根结点
 typedef struct TreeNode TNode;
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {
    if(inorderSize == 0)
    {
        return NULL;
    }

    TNode* root = (TNode*)malloc(sizeof(TNode));
    root->val = postorder[postorderSize-1];

    int i = 0;
    for(i = 0; i < postorderSize; i ++ )
    {
        if(postorder[postorderSize-1] == inorder[i])
        {
            break;
        }
    }

    root->left = buildTree(inorder , i, postorder, i);
    root->right = buildTree(inorder + 1 + i, inorderSize - 1 - i, postorder + i, postorderSize - 1 - i);

    return root;
}
```

