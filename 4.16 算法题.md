## [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

![image-20250416101259671](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250416101259671.png)



```c
typedef struct {
    int stackInTop, stackOutTop;
    int stackIn[110], stackOut[110];
} MyQueue;

MyQueue* myQueueCreate() {
	// 一个队列的大小空间
    MyQueue* queue = (MyQueue*)malloc(sizeof(MyQueue));
    queue->stackInTop = 0; // 初始化栈顶 
    queue->stackOutTop = 0;
    return queue;
}

void myQueuePush(MyQueue* obj, int x) {
    obj->stackIn[(obj->stackInTop)++] = x; // 入栈 
}

int myQueuePop(MyQueue* obj) {
    int stackInTop = obj->stackInTop;
    int stackOutTop = obj->stackOutTop;
    //若输出栈为空
    if(stackOutTop == 0) {
        //将第一个栈中元素复制到第二个栈中
        while(stackInTop > 0) {
            obj->stackOut[stackOutTop++] = obj->stackIn[--stackInTop];
        }
    }
    //将第二个栈中栈顶元素出栈
    int top = obj->stackOut[--stackOutTop];
    //将输出栈中元素放回输入栈中
    while(stackOutTop > 0) {
        obj->stackIn[stackInTop++] = obj->stackOut[--stackOutTop];
    }
    //更新栈顶指针
    obj->stackInTop = stackInTop;
    obj->stackOutTop = stackOutTop;
    //返回队列中第一个元素
    return top;
}

//返回输入栈中的栈底元素
int myQueuePeek(MyQueue* obj) {
    return obj->stackIn[0];
}

//若栈顶均为0，则代表队列为空
bool myQueueEmpty(MyQueue* obj) {
    return obj->stackInTop == 0 && obj->stackOutTop == 0;
}

//栈顶置零 
void myQueueFree(MyQueue* obj) {
    obj->stackInTop = 0;
    obj->stackOutTop = 0;
}
```



## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

![image-20250416102914397](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250416102914397.png)



```c
// 学习例题 
int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

bool dfs(char** board, char* word, int m, int n, int i, int j, int k) {
    if (board[i][j] != word[k])
	{
        return false; // 匹配失败
    }
    if (word[k + 1] == '\0')
	{
        return true; // 匹配成功 
    }
    board[i][j] = 0; // 标记
    
    for (int d = 0; d < 4; d ++)
	{
        int x = i + dir[d][0], y = j + dir[d][1]; // 相邻格子
        if (0 <= x && x < m && 0 <= y && y < n && dfs(board, word, m, n, x, y, k + 1))
		{
            return true; // 查找到 
        }
    }
    board[i][j] = word[k]; // 恢复
    return false; // 没找到 
}

bool exist(char** board, int boardSize, int* boardColSize, char* word) {
    int m = boardSize, n = boardColSize[0];
    
    for (int i = 0; i < m; i ++)
	{
        for (int j = 0; j < n; j ++)
		{
            if (dfs(board, word, m, n, i, j, 0))
			{
                return true; // 找到了 
            }
        }
    }
    return false; // 没找到
}
```

