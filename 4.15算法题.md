## [**141. 环形链表**](https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&envId=top-100-liked)

![](https://kevin-java.oss-cn-hongkong.aliyuncs.com/2025/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-15%20213725.png)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null){
            return false;
        }
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
}
```

## [**142. 环形链表 II**](https://leetcode.cn/problems/linked-list-cycle-ii/)

![](https://kevin-java.oss-cn-hongkong.aliyuncs.com/2025/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-15%20214628.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) { // 处理空链表或只有一个节点的链表
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;

        // 第一阶段：寻找相遇点
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) { // 相遇，跳出循环
                break;
            }
        }

        // **** 修正关键点 ****
        // 在循环结束后，检查是否是因为 fast 走到了链表末尾而结束（即无环）
        if (fast == null || fast.next == null) {
            return null; // 没有环，返回 null
        }

        // 第二阶段：寻找环的入口
        // 能执行到这里，说明一定有环，且 slow 和 fast 在相遇点
        slow = head; // 将 slow 重置回头节点
        while (slow != fast) { // 当 slow 和 fast 再次相遇时，就是入口节点
            slow = slow.next;
            fast = fast.next; // fast 现在也每次走一步
        }

        return slow; // 返回入口节点
    }
}
```
