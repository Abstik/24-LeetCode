## [LCR 171. 训练计划 V](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) 

![image-20250415165231860](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250415165231860.png) 

```c
struct ListNode* getIntersectionNode(struct ListNode* headA,struct ListNode* headB) {
    struct ListNode *l, *s;//分别定义储存长短链表的指针
    int lenA = 0, lenB = 0, gap = 0;
    s = headA;
    while (s) {//获取两链表的长度
        s = s->next;
        lenA++;
    }
    s = headB;
    while (s) {
        s = s->next;
        lenB++;
    }
    if (lenA > lenB) {//得到长短链表之差
        l = headA;
        s = headB;
        gap = lenA - lenB;
    } else {
        l = headB;
        s = headA;
        gap = lenB - lenA;
    }
    while (gap--) {//移动长链表节点到与短链表头节点相同位置
        l = l->next;
    }
    while (l) {//同时移动找到节点
        if (l == s) {
            return l;
        }
        l = l->next;
        s = s->next;
    }
    return NULL;
}
```

## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 

![image-20250415165356779](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250415165356779.png)

```c
struct ListNode* swapPairs(struct ListNode* head) {
    if(head==NULL||head->next == NULL){//头节点不存在或头节点的下一个节点不存在。此时不需要交换，直接返回head
        return head;
    }
    struct ListNode* newhead = head->next;////创建一个节点指针类型保存头结点下一个节点
    head->next = swapPairs(newhead->next//更改头结点+2位节点后的值，并将头结点的next指针指向这个更改过的链表
    newhead->next = head//将新的头结点的next指针指向老的头节点
    return newhead;
}
```

