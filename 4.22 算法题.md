## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

![](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250422155441782.png)



```c
struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)
{
	if (inorderSize == 0) // 长度为0，空结点 
	{
		return NULL;
	}
	struct TreeNode* node = malloc(sizeof(struct TreeNode));
	node->val = preorder[0]; // 前序数组的第一位必为根结点 
	node->left = NULL;
	node->right = NULL;
	
	int index; // 在中序数组找到根结点 
	for (index = 0; inorder[index] != node->val; index++);
	// 则其左侧为根的左子树，右侧为根的右子树。递归处理 
	node->left = buildTree(preorder + 1, index, inorder, index);
	node->right = buildTree(preorder + index + 1, inorderSize - index - 1, inorder + index + 1, inorderSize - index - 1);
	
	return node;
}
```



## [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

![image-20250422155654094](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250422155654094.png)



```c
struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize)
{
    if(inorderSize == 0) // 长度为0，空结点 
    {
    	return NULL;
	}
    struct TreeNode* node = malloc(sizeof(struct TreeNode));
    node->val = postorder[postorderSize - 1]; // 后序数组末尾元素必为根 
    
    int index; // 找到中序数组的根节点 
    for (index = 0; inorder[index] != node->val; index++);
    // 递归处理 
    node->left = buildTree(inorder, index, postorder, index);
    node->right = buildTree(inorder + index + 1, postorderSize - index - 1, postorder + index, postorderSize - index - 1);
    
	return node;
}
```



## [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

![image-20250422160000646](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250422160000646.png)



```c
struct Node* connect(struct Node* root)
{
	if (root == NULL)
	{
		return root; // 空结点 
	}
	// 模拟队列 
	int front = 0, rear = 0;
	struct Node* queue[6010];
	queue[rear++] = root;
	
	while (front != rear)
	{
		int len = rear - front; // 获取每一层的结点数量 
		while (len > 0)
		{
			len--;
			struct Node* curr = queue[front++];
			// len不为0，则层结点还有后继
			// len为0，说明为一层的末结点，next指NULL 
			if (len != 0) curr->next = queue[front];
			else curr->next = NULL;
			// 左右孩子各自入栈——前提不为NULL 
			if (curr->left != NULL) queue[rear++] = curr->left;
			if (curr->right != NULL) queue[rear++] = curr->right;
		}
	}
	return root;
}
```

