## [150. 逆波兰表达式求值 ](https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/624355159/)

![image-20250422165403872](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504221654149.png)

```C
//平时写的 1+1 -- 二叉树中序
//后缀表达式 -- 二叉树后序

//栈 遇数字--入栈  
//   遇符号--出栈 进行运算 结果入栈

//用数组模拟栈

bool inNumber(char* token)//判断是不是数字
{
    return (strlen(token) > 1) || ('0' <= token[0] && token[0] <= '9' );
}

int evalRPN(char** tokens, int tokensSize) {
    int arr[tokensSize];//模拟栈
    int top = 0;//记录栈顶的位置

    for(int i = 0; i < tokensSize; i ++ )
    {
        char* ss = tokens[i];//转成字符串
        if(inNumber(ss))//是数字
        {
            arr[top++] = atoi(ss);
        }
        else //不是数字 出两个元素
        {
            int num1 = arr[--top];
            int num2 = arr[--top];
            switch (ss[0])//判断运算符
            {
                case '+':
                    arr[top++] = num1 + num2;
                    break;
                case '-':
                    arr[top++] = num2 - num1;
                    break;
                case '*':
                    arr[top++] = num1 * num2;
                    break;
                case '/':
                    arr[top++] = num2 / num1;
                    break;
            }

        }
    }
    return arr[top-1];//最终arr中只会有一个元素 即为返回值
}
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/submissions/624279287/)

![image-20250422165326504](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504221653863.png)

```C
//固定一个数 用三数之和
//a b left right
//a b不和前一个重复 left符合条件后不重复

int cmp (const void* x, const void* y)
{
    return *(int*)x - *(int*)y;
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {
    int** ret = (int**)malloc(sizeof(int*) * 18000);//返回数组
    *returnSize = 0;//初始为0
    //如果没有四个数 直接返回
    if(numsSize < 4)
    {
        return ret;
    }

    //排序
    qsort(nums, numsSize, sizeof(int), cmp);

    for(int i = 0; i < numsSize - 3; i ++ )
    {
        //去重
        if(i > 0 && (nums[i] == nums[i-1]))
        {
            continue;
        }

        for(int j = i+1; j < numsSize - 2; j ++)
        {
            if((j > i+1) && (nums[j-1] == nums[j]))
            {
                continue;
            }
            long long int ss = nums[i] + nums[j];
            int left = j+1;
            int right = numsSize-1;
            while(left < right)
            {
                long long int s = nums[left] + nums[right];
                if(target > (s + ss))
                {
                    left++;
                }
                else if(target == (s + ss))
                {
                    int* arr = (int*)malloc(sizeof(int) * 4);
                    arr[0] = nums[i];
                    arr[1] = nums[j];
                    arr[2] = nums[left];
                    arr[3] = nums[right];
                    ret[(*returnSize) ++ ] = arr;

                    //去重
                    while(left < right && (nums[left + 1] == nums[left]))
                    {
                        left++;
                    }
                    left ++ ;
                    while(left < right && (nums[right-1] == nums[right]))
                    {
                        right--;
                    }
                    right--;
                }
                else 
                {
                    right--;
                }
            }
        }
    }

    *returnColumnSizes = (int*)malloc(sizeof(int) * (*returnSize));
    for(int k = 0; k < *returnSize; k ++ )
    {
        (*returnColumnSizes)[k] = 4;
    }

    return ret;
}
```

