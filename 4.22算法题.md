## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) 

![image-20250420211019148](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250420211019148.png) 

```c
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {
    //整体思路：使用双端队列来找每个窗口的最大值（头部移除已经不在窗口的元素，尾部移除较小元素），通过获取元素的索引遍历当前元素（也是通过索引移除元素）
    *returnSize=numsSize-k+1;//返回结果数组的大小，即获得的(每个窗口)最大值的个数
    int *res=(int*)malloc((*returnSize)*sizeof(int));//分配内存
    int *deque=(int*)malloc((numsSize)*sizeof(int));
    int front=0,rear=0,idx=0;//分别用于头部，尾部和结果数组
    for(int i=0;i<numsSize;i++){//遍历
        while(front<rear&&deque[front]<=i-k){//检查队列是否为空的同时查看头部元素是否还在窗口内，可知窗口范围为[i-k+1,k]
            front++;//不在则移除
        }
        while(front<rear&&nums[deque[rear-1]]<=nums[i]){//检查队列是否为空的同时移除队列中所有小于当前元素的元素（从队列尾部移除），这样可以保持队列中的元素是单调递减的，因为rear指向下一个空位，所以要-1
            rear--;
        }
        deque[rear++]=i;//将当前元素的索引添加到队列尾部
        if(i-k+1>=0){//当窗口形成后（i >= k-1），将当前窗口的最大值（队列头部元素）存入结果数组
            res[idx++]=nums[deque[front]];
        }
    }
    return res;
}
```

## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 

![image-20250420211023443](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250420211023443.png) 

```c
//整体思路：本题涉及uthash库，最小堆，原理是使用哈希表统计每个数字出现的频率，使用大小为K的最小堆来维护前K个高频元素，当堆未满时，直接插入元素，当堆已满时，只有当前元素的频率大于堆顶元素的频率时，才替换堆顶元素
struct hash_table {
    int key;// 存储数组中的数字
    int val;// 存储该数字出现的频率
    UT_hash_handle hh;//是 uthash 这个C语言哈希表库中的一个必需字段，它用于内部记录哈希表的链接信息
};
typedef struct hash_table* hash_ptr;// 哈希表指针类型别名
struct pair {
    int first;     // 存储数字
    int second;    // 存储频率
};
struct pair* heap;  // 堆数组，用于维护前K个高频元素
int heapSize;       // 当前堆大小

// 交换两个pair结构体
void swap(struct pair* a, struct pair* b) {
    struct pair t = *a;
    *a = *b, *b = t;
}

// 比较函数，a的频率是否小于b的频率
bool cmp(struct pair* a, struct pair* b) {
    return a->second < b->second;
}

// 获取堆顶元素
struct pair top() {
    return heap[1];
}

// 向堆中插入元素
void push(hash_ptr x) {
    heap[++heapSize].first = x->key;   // 插入到堆末尾
    heap[heapSize].second = x->val;
    int p = heapSize, s;
    // 上浮操作
    while (p > 1) {
        s = p >> 1;  // 父节点
        if (cmp(&heap[s], &heap[p])) return;  // 如果父节点更小，停止
        swap(&heap[p], &heap[s]);  // 否则交换
        p = s;
    }
}

// 弹出堆顶元素
void pop() {
    heap[1] = heap[heapSize--];  // 用最后一个元素替换堆顶
    int p = 1, s;
    // 下沉操作
    while ((p << 1) <= heapSize) {
        s = p << 1;  // 左子节点
        if (s < heapSize && cmp(&heap[s + 1], &heap[s])) s++;  // 选择较小的子节点
        if (cmp(&heap[p], &heap[s])) return;  // 如果父节点更小，停止
        swap(&heap[p], &heap[s]);  // 否则交换
        p = s;
    }
}
int* topKFrequent(int* nums, int numsSize, int k, int* returnSize) {
    // 初始化哈希表
    hash_ptr head = NULL;
    hash_ptr p = NULL, tmp = NULL;

    // 统计每个数字的频率
    for (int i = 0; i < numsSize; i++) {
        HASH_FIND_INT(head, &nums[i], p);  // 查找当前数字是否已存在
        if (p == NULL) {
            // 不存在则创建新条目
            p = malloc(sizeof(struct hash_table));
            p->key = nums[i];
            p->val = 1;
            HASH_ADD_INT(head, key, p);  // 添加到哈希表
        } else {
            p->val++;  // 存在则频率加1
        }
    }

    // 初始化大小为k的最小堆
    heap = malloc(sizeof(struct pair) * (k + 1));
    heapSize = 0;

    // 遍历哈希表，维护前K个高频元素
    HASH_ITER(hh, head, p, tmp) {
        if (heapSize == k) {
            // 堆已满，比较当前元素与堆顶
            struct pair tmp = top();
            if (tmp.second < p->val) {
                pop();  // 弹出堆顶（最小频率）
                push(p); // 插入当前元素
            }
        } else {
            push(p);  // 堆未满，直接插入
        }
    }
    
    // 准备返回结果
    *returnSize = k;
    int* ret = malloc(sizeof(int) * k);
    // 从堆中取出元素（逆序，因为是最小堆）
    for (int i = 0; i < k; i++) {
        struct pair tmp = top();
        pop();
        ret[i] = tmp.first;
    }
    return ret;
}
//补充知识：父节点位置 = 子节点位置 / 2（整数除法）。
//左子节点 = 父节点 * 2
//右子节点 = 父节点 * 2 + 1
```

