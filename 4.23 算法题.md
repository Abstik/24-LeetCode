## [102. 二叉树的层序遍历 ](https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/624884234/)

![image-20250423162306706](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504231623116.png)

```C
typedef struct TreeNode TNode;

//根结点入队 
//结点出队后 将左右孩子入队 
//之后再取队中元素 

int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes) 
{
    *returnSize = 0;//初始为零

    TNode* queue[2000];//模拟队列 存储结点
    int** ret = (int**)malloc(sizeof(int*) * 2000);//返回的数组
    *returnColumnSizes = malloc(sizeof(int) * 2000);

    if(root == NULL)
    {
        return ret;//头结点为空直接返回
    }

    int front = 0;
    int back = 0;//记录队头队尾

    //头结点入队 -- 队尾
    queue[back ++ ] = root;
    // (*ret)[*returnSize ++ ] = nhead->val;//数据存入数组

    while(front != back)//队列不为空 循环
    {
        int len = back - front;//记录每一层的结点个数
        ret[*returnSize] = malloc(sizeof(int) * len);//存储每一层数据

        //移动到下一层
        int start = front;
        front = back;
        for(int i = start; i < front; i ++ )//从每一层的开始到结束
        {
            ret[*returnSize][i-start] = queue[i]->val;//将本层的每一个元素加入数组
            if(queue[i]->left)//左孩子不为空 入队
            {
                queue[back++] = queue[i]->left;
            }
            if(queue[i]->right)//右孩子不为空 入队
            {
                queue[back++] = queue[i]->right;
            }

        }
        (*returnColumnSizes)[(*returnSize)++] = len;//returnSize代表的是层数 表示第i层的元素个数是几
    }
    return ret;
}
```

## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/submissions/624890646/)

![image-20250423163745137](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504231637498.png)

```C
typedef struct TreeNode TNode;

int* largestValues(struct TreeNode* root, int* returnSize) {
    *returnSize = 0;
    int* ret = (int*)malloc(sizeof(int) * 10005);//返回数组
    if(root == NULL)
    {
        return ret;
    }

    //用队列 入队列 队头出 存入左右孩子
    TNode** queue = (TNode**)malloc(sizeof(TNode*) * 10000);

    int front = 0;
    int back = 0;
    
    queue[back++] = root;//存入根结点
    while(front < back)
    {
        int max = -pow(2,31);

        //遍历每一层
        int len = back - front;
        int start = front;//每层 从开始到循环结束的位置
        front = back;

        for(int i = start; i < front; i ++ )//遍历本层每一个结点
        {
            if(queue[i]->val > max)
            {
                max = queue[i]->val;
            }
            if(queue[i]->left)
            {
                queue[back++] = queue[i]->left;
            }
            if(queue[i]->right)
            {
                queue[back++] = queue[i]->right;
            }
        }
        //记录这一层的最大值
        ret[(*returnSize) ++ ] = max;
    }

    return ret;
}
```

