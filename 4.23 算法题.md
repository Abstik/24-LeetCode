## [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

![image-20250423111736248](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250423111736248.png)



```c
void calPaths(struct TreeNode* root, char** rt, int* st, int top, int* returnSize)
{
    if(root == NULL)
    {
    	return ;
	}
    else
	{
        // 当前节点不为叶子节点 
        if(root->left != NULL || root->right != NULL)
		{
            st[++top] = root->val;
            calPaths(root->left, rt, st, top, returnSize); 
            calPaths(root->right, rt, st, top, returnSize);    
        }
        // 当前节点为叶子节点，说明某一条路径构建完毕 
        else
		{
            char* s = (char*)malloc(sizeof(char) * 500);
            int len = 0;                        
            // 经过上述if语句的操作，栈内节点组成某一条路径但不包含最后的叶子节点
            for(int i = 0; i <= top; i ++)
			{
                len += sprintf(s + len, "%d->", st[i]);
            }
            sprintf(s + len, "%d", root->val); 
            rt[(*returnSize)++] = s;                  
        }
    }
}

char** binaryTreePaths(struct TreeNode* root, int* returnSize)
{
    char** rt = (char**)malloc(sizeof(char*) * 110);
    // 初始化路径数
    *returnSize = 0;
    // 模拟栈 
    int st[110];
    calPaths(root, rt, st, -1, returnSize);
    
    return rt;                                         
}
```



## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

![image-20250423112253696](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250423112253696.png)



```c
int getHeight(struct TreeNode* node)
{
    if (node == NULL) // 空结点 
	{
        return 0;
    }

    int lefth = getHeight(node->left);
    if (lefth == -1)
	{
        return -1; // 停止递归
    }
    int righth = getHeight(node->right);
    if (righth == -1 || abs(lefth - righth) > 1) // 高度差亦需判断 
	{
        return -1;
    }

    return fmax(lefth, righth) + 1;
}

bool isBalanced(struct TreeNode* root)
{
    return getHeight(root) != -1;
}
```

