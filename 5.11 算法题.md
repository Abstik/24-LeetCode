

## [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/submissions/629037835/)

![image-20250511173312466](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505111733792.png)

```go
//按照左边界从小到大排序 有几个重叠的区间就删几个

func eraseOverlapIntervals(intervals [][]int) int {
	//排序
	sort.Slice(intervals, func(i, j int) bool {
		if intervals[i][0] == intervals[j][0] {
			return intervals[i][1] < intervals[j][1] // 第一列相同时，按照第二列排序
		} else {
			return intervals[i][0] < intervals[j][0]
		}
	})
	cnt := 0
	for i := 1; i < len(intervals); i++ {
		//如果下一个的左边界小于上一个的右边界 表示有重叠
		if intervals[i][0] < intervals[i-1][1] {
			cnt++
			//更新右边界  取更小的 和后面的重可能性更小
			if intervals[i-1][1] < intervals[i][1] {
				intervals[i][1] = intervals[i-1][1]
			}
		}
	}
	return cnt
}
```

## [763. 划分字母区间 ](https://leetcode.cn/problems/partition-labels/)

![image-20250511174758544](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505111747890.png)

```go
//一个字母只出现在一个区间
//取每个字符最远出现的位置 这个位置之前一定全部要包括 
func partitionLabels(s string) []int {
    length := make([]int,0,500)

    distance := make([]int,0,26)
    for i:=0; i<26; i++{
        distance = append(distance,0)  //首先用0填充
    }
    for index,value := range s{
        distance[value-'a'] = index   //最远位置

    }

    //遍历数组
    start := 0
    end := distance[s[0] - 'a'] //初始
    for index,value := range s{
        if distance[value - 'a'] > end{
            end = distance[value - 'a']  //更新最远位置
        }
        //如果到了最远位置 更新start  并将长度存入数组
        if index == end {
            len := end - start + 1
            start = index+1
            length = append(length,len)
        }
    }
    return length
}
```

