## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

![image-20250511190915779](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250511190915779.png)



```go
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func canJump(nums []int) bool {
	furthest := 0 // 记录当前能够到达的最远位置的索引

	for i, next := range nums {
		// 如果当前位置的索引 i 大于能够到达的最远位置 furthest
		// 说明无法到达位置 i，直接返回 false
		if i > furthest {
			return false // 无法到达i
		}
		// 更新能够到达的最远位置
		// 从当前位置 i 出发，最远可以跳到 i + next 的位置
		// 取 furthest 和 i+next 中的较大值作为新的最远位置
		furthest = max(furthest, i+next) // 从i最右可以跳到i+next

		// 如果最远位置已经能够到达或超过数组的最后一个位置
		// 说明可以跳到终点，提前结束循环
		if furthest >= len(nums)-1 { // 可以跳到n-1
			break
		}
	}
	return true
}
```



## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

![image-20250511192159338](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250511192159338.png)



```go
func minPathSum(grid [][]int) int { // 记忆化搜索
    m, n := len(grid), len(grid[0])
    
    // 创建记忆化数组，index[i][j] 存储从起点到(i,j)的最小路径和
    index := make([][]int, m)
    for i := range index {
        index[i] = make([]int, n)
        for j := range index[i] {
            index[i][j] = -1 // -1 表示没有计算过
        }
    }

    // 返回最小路径和
    var dfs func(int, int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 {
            return math.MaxInt // 越界返回极大值
        }
        
        if i == 0 && j == 0 {
            return grid[i][j] // 起点，直接返回
        }
        
        p := &index[i][j]
        if *p == -1 {
            // 状态转移方程
            *p = min(dfs(i, j-1), dfs(i-1, j)) + grid[i][j]
        }
        return *p
    }
    
    return dfs(m-1, n-1)
}
```

