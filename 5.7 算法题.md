## [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

![image-20250507202446396](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250507202446396.png)



```go
func jump(nums []int) int {
	// farthest 用于记录当前能到达的最远位置
	// cnt 用于记录跳跃的步数
	// left 和 right 分别表示当前跳跃范围的左右边界
	farthest, cnt, left, right := 0, 0, 0, 0
	// 当右边界小于数组长度减 1 时，继续循环
	for right < len(nums)-1 {
		// 遍历当前跳跃范围
		for curr := left; curr <= right; curr++ {
			// 更新能到达的最远位置
			if curr+nums[curr] > farthest {
				farthest = curr + nums[curr]
			}
		}
		cnt++
		// 更新左边界为上一次右边界加 1
		left = right + 1
		// 更新右边界为能到达的最远位置
		right = farthest
	}
	return cnt
}
```



## [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

![image-20250507204358483](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250507204358483.png)



```go
func removeDuplicateLetters(s string) string {
	cnt := [26]int{} // 记录每个字母的出现次数
	for _, ch := range s {
		cnt[ch-'a']++
	}
	stack := []byte{}    // 模拟栈
	isPush := [26]bool{} // 记录每个字母是否已经入栈

	for i := range s {
		ch := s[i]
		if !isPush[ch-'a'] {
			// 未入栈，且栈不为空，且当前字符的字典序小于栈顶字符的字典序
            // 且栈顶字符在后续字符串中还存在
			for len(stack) > 0 && ch < stack[len(stack)-1] {
				last := stack[len(stack)-1] - 'a'
				// 如果栈顶字符在后续字符串中不会再出现，则不再出栈
				if cnt[last] == 0 {
					break
				}
				stack = stack[:len(stack)-1] // 出栈
				isPush[last] = false         // 标记栈顶字符不在栈中
			}
			stack = append(stack, ch) // 入栈
			isPush[ch-'a'] = true     // 标记当前字符已入栈
		}
		cnt[ch-'a']--
	}
	return string(stack)
}
```

