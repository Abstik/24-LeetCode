## [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/) 

![image-20250504190915689](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250504190915689.png) 

```c
char* removeKdigits(char* num, int k) {
    //整体思路：运用贪心加单调栈的思想，比较数字序列中一个数与它左边的数的大小，如果序列中当前的数比它左边的数小，将它左边的数出栈(左边的数已入栈)，用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数，在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。
    int n = strlen(num);//获取字符串长度
    int top = 0;//设置栈顶指针
    char* stk = calloc(n + 1, sizeof(char));//创建栈，n+1是因为top设置为0，索引从1开始
    for (int i = 0; i < n; i++) {
        while (top > 0 && stk[top] > num[i] && k > 0) {//如果栈内有值，栈顶元素比当前遍历到的数字大且还未移除完k位数字，出栈，并减少k的值
            top--;
            k--;
        }
        stk[++top] = num[i];//否则入栈
    }
    top -= k;//无论k是否减到0，都可以减去，不影响结果，这里是为了保证如果遇到一个单调序列，那么不会有数字入栈，所以最后只需要减去最后的几位数字即可
    char* ans = calloc(n + 1, sizeof(char));//创建结果数组
    int ansSize = 0;//用于添加结果
    bool isLeadingZero = true;//前导0，若最后得到的序列中第一位为0，用于判断它是否被去除
    for (int i = 1; i <= top; i++) {
        if (isLeadingZero && stk[i] == '0') {//如果前导0为true且当前数字为0，用continue跳过本轮剩下的程序即可去除
            continue;
        }
        isLeadingZero = false;//如果第一位不为0，则设置为false
        ans[ansSize++] = stk[i];
    }
    if (ansSize == 0) {//如果没有得到结果
        ans[0] = '0';//设置为0
        ans[1] = '\0';//结束符
    } else {
        ans[ansSize] = '\0';//否则直接设置为结束符号
    }
    return ans;
}
```

