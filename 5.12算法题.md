## [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/) 

![image-20250510215603183](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250510215603183.png) 

```go
//go语言版本
func nextGreaterElements(nums []int) []int {
    ans :=make([]int,len(nums))
    for i :=range ans{
        ans[i]=-1
    }
    stack :=make([]int,len(nums))
    for i :=0;i<len(nums)*2;i++{
        for len(stack)>0&&nums[i%len(nums)]>nums[stack[len(stack)-1]] {
            ans[stack[len(stack)-1]]=nums[i%len(nums)]
            stack=stack[:len(stack)-1]
        }
        if i<len(nums) {
            stack=append(stack,i)
        }
    }
    return ans
}
```

```go
int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {
    //整体思路:本题目需要循环寻找数组中比当前遍历到的数大的数，可以把nums复制一份，在代码中可以用i<numsSize*2表示，也就是遍历两遍数组，这样就把数组前后接起来了，但在获取索引时要加入i<numsSize的限制条件
    *returnSize=numsSize;//获取数组长度
    int* ans=calloc(*returnSize,sizeof(int));
    int* stack=calloc(*returnSize,sizeof(int));
    int top=-1;//栈顶指针
    memset(ans,-1,numsSize*sizeof(int));//初始化结果数组都为-1,假设没有更大的数
    for(int i=0;i<numsSize*2;i++){//两重循环遍历数组
        int cur=nums[i%numsSize];//用取余表示实际上在数组中的位置
        while(top>=0&&cur>nums[stack[top]]){//如果栈内有元素且当前值比栈顶指针大
            ans[stack[top--]]=cur;//更换栈顶元素
        }
        if(i<numsSize){//如果小于栈顶指针且当前遍历值在numsSize内
            stack[++top]=i;//索引入栈
        }
    }
    return ans;
}
```



