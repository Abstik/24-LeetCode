## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

![image-20250417205216308](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250417205216308.png)



```c
// 遍历记录的方式，复杂度取决于排序；另有哈希及堆解法
typedef struct
{
	int i;
	int cnt;
} SUM; // 记录对应数及其出现次数 

int cmp1(const void *a, const void *b)
{
	// 对nums排序 
    return *(int*)a - *(int*)b;
}

int cmp2(const void *a, const void *b)
{
	// 对sum排序 
    return (*(SUM*)b).cnt - (*(SUM*)a).cnt;
}

int* topKFrequent(int* nums, int numsSize, int k, int* returnSize) {
    *returnSize = k;
    int *rt = (int*)malloc(sizeof(int) * numsSize);
    SUM sum[numsSize];
    int p = 0;
    
    qsort(nums, numsSize, sizeof(int), cmp1); // 使nums有序 
    sum[p].i = nums[0]; // 初始化第一个数 
    sum[p].cnt = 1;
    for (int i = 1; i < numsSize; i ++)
    {
    	if (nums[i] == nums[i - 1]) // 一样，说明数字相同，继续加 
    	{
    		sum[p].cnt ++;
		}
		else // 不一样，其他数，新增一个记录 
		{
			sum[++ p].i = nums[i];
			sum[p].cnt = 1;
		}
	}
	
	qsort(sum, p + 1, sizeof(SUM), cmp2); // 按出现次数降序排序 
	for (int i = 0; i < k; i ++)
	{
		rt[i] = sum[i].i; // rt记录前k种数 
	}
	return rt;
}
```



## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

![image-20250417215836181](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250417215836181.png)



```C
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {
    *returnSize = numsSize - k + 1;
    int* ans = malloc((*returnSize) * sizeof(int));
    int* q = malloc(numsSize * sizeof(int)); // 用数组模拟双端队列
    int front = 0, rear = 0; // 双端队列的队首和队尾
    for (int i = 0; i < numsSize; i ++)
	{
        while (front < rear && nums[q[rear - 1]] <= nums[i])
		{
            rear --; // 维护 q 的单调性
        }
        q[rear ++] = i; // 入队
        if (q[front] <= i - k)
		{
			// 队首离开窗口
            front ++;
        }
        if (i >= k - 1)
		{
            // 队首到队尾递减，所以窗口最大值就是队首
            ans[i - k + 1] = nums[q[front]];
        }
    }
    free(q);
    return ans;
}
```

