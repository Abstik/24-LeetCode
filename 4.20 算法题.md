## [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/623763444/)

![image-20250420180812892](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504201808011.png)

```C
//因为都是正数 若[i,j]个数满足要求 则[i,j+1]个数也满足要求
//缩小满足要求的区间，left++

int minSubArrayLen(int target, int* nums, int numsSize) {
    int min = 100001;
    int left = 0;
    int right = 0;
    int sum = 0;
    while(right < numsSize)//保证不越界
    {
        sum += nums[right];
        if(sum >= target)
        {
            int t = right - left + 1;
            min = t<min ? t:min;//更新子数组长度
            //缩短子串长度
            while(sum - nums[left] >= target)
            {
                sum -= nums[left];
                left++;
                t = right - left + 1;
                min = t<min ?t :min;
            }
        }
        right ++ ;
    }
    if(min == 100001)//没有符合条件的
    {
        return 0;
    }
    return min;
}
```

## [3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![image-20250420180918897](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504201809021.png)

```C
//遍历字符串 如果遍历到新的字符串前面出现过 那么将左边界向右移或者不动（不动是因为在前面出现过的位置不在left到right之间）
//需要注意 字符不只包括字母

#define MAX(a,b) a>b?a:b

int lengthOfLongestSubstring(char* s)
{
    int len = strlen(s);
    //记录每一种字符上次出现的位置 初始都为-1
    int last[255] = { 0 };
    for (int i = 0; i < 255; i++)
    {
        last[i] = -1;
    }

    int left = 0;
    int right = 0;

    int max = 0;

    while (*s != '\0')
    {
        if (last[*s] != -1)//之前的字符串中有出现过
        {
            left = MAX(left,(last[*s] + 1));
        }

        last[*s] = right;//更新

        int t = right - left + 1;
        max = t > max ? t : max;
        right++;
        s++;
    }
    return max;
}
```

## [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/submissions/623932821/)

![image-20250420153701130](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504201537442.png)

```c
//负债问题 如果t = 'aabc' ->给一个数组arr 使得arr[a]=-2 arr[b]=-1 arr[c]=-1 其他为零

char* minWindow(char* s, char* t) {
    int tar[500] = { 0 };
    int debt = 0;

    int len = strlen(s);
    char* ss = (char*)malloc(sizeof(char) * (len+1));
    int len2 = strlen(t);
    if(len2 > len)
    {
        return ""; 
    }
    
    for(int i = 0 ; i < len ; i ++)
    {
        ss[i] = s[i];
    }
    // ss[len] = '\0';

    //将字符串t中的值保存
    while (*t != '\0')
    {
        tar[*t]--;
        t++;
        debt++;
    }

    int left = 0;
    int right = 0;
    int start = 0;//用来记录返回的数组的下标
    int min = 100001;//最小长度
    while (*s != '\0')
    {
        
        if (tar[*s] < 0)
        {
            debt--;//负债减少
        }
        tar[*s]++;

        if (debt == 0)//缩小左边界
        {
            while (tar[*(ss+left)] > 0)
            {
                tar[*(ss + left)]--;
                left++;
            }
            int t = right - left + 1;
            if (t < min)
            {
                start = left;
                min = t;
            }
        }

        right++;
        s++;
    }

    if (min == 100001)
    {
        return "";
    }

    //返回从开始位置到min长度
    ss[start + min] = '\0';
    return &ss[start];
}
```

