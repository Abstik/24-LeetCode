## [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/submissions/623723368/)

![image-20250419173938866](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504191739205.png)

```C
//用两个栈来实现

//栈的结构
typedef struct Stack
{
    char* data;
    int size;
    int capacity;
}Stack;

//初始化
void stackInit(Stack* S)
{
    S->data = NULL;
    S->capacity = S->size = 0;
}

//销毁
void stackDestroy(Stack* S)
{
    free(S->data);
    S->data = NULL;
    S->capacity = S->size = 0;
}

//判空
bool stackEmpty(Stack *S)
{
    return S->size == 0;
}
//入栈 -- 栈顶 数组尾
void stackPush(Stack* S, char x)
{
    //判断空间是否足够
    if(S->size == S->capacity)//空间不足 扩容
    {
        int newCapacity = (S->capacity == 0)? 4: 2*S->capacity;
        char* tmp = realloc(S->data, sizeof(char)* newCapacity);
        S->data = tmp;
        S->capacity = newCapacity;
    }
    S->data[S->size ++ ] = x;
}

//出栈 -- 栈顶
void stackPop(Stack*S)
{
    if(stackEmpty(S))//栈为空
    {
        return ;
    }

    S->size -- ;
}

//取栈顶元素
char stackTop(Stack* S)
{
    return S->data[S->size - 1];
}

//首先将所有元素入栈S1
//将栈S1中的元素出到S2中 直到遇到空格 
//遇到空格就将S2中的元素存入数组 再将空格存入新数组
//重复这个过程 直到栈S1为空


//反转
char* reverseWords(char* s) {

    int len = strlen(s);
    char* str = (char*)malloc(sizeof(char) * (len*2));
    
    Stack S1;
    Stack S2;
    stackInit(&S1);
    stackInit(&S2);

    int i = 0;
    //所有元素入栈
    while(s[i] != '\0')
    {
        stackPush(&S1, s[i]);
        i++;
    }

    int j = 0;
    while(!stackEmpty(&S1))//S1不为空
    {
        char t = stackTop(&S1);
        stackPop(&S1);
        if(t == ' ')//遇到空格 先将S2中的元素存入字符串 再将空格存进去
        {
            while(!stackEmpty(&S2))
            {
                char m = stackTop(&S2);
                stackPop(&S2);
                str[j++] = m;
            }
            if(j == 0 || (j > 0 && str[j-1] == ' '))
            {
                continue;
            }
            str[j++] = t;
        }
        else //不是空格 入栈S2
        {
            stackPush(&S2, t);
        }
    }
    //如果S2还有元素 放进str
    while(!stackEmpty(&S2))
    {
        char a = stackTop(&S2);
        stackPop(&S2);
        str[j++] = a;
    }

    //此时str中有j个元素 最后一个下标是j-1
    while(str[j-1] == ' ')
    {
        j--;
    }
    str[j] = '\0';

    i = 0;
    return str;
}
```

## [215. 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/submissions/623733308/)

![image-20250419182617279](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202504191826424.png)

```c
//堆排序 -- 小根堆 --父结点比子结点小->交换

//向下调整
void adjustDown(int* arr, int parent, int n)
{
    int child = 2 * parent + 1;
    while(child < n)//保证左孩子不越界
    {
        if(child+1 < n && arr[child] > arr[child+1])//右孩子不越界 并且右孩子大于左孩子
        {
            child++;
        }
        if(arr[child] < arr[parent])
        {
            int t = arr[child];
            arr[child] = arr[parent];
            arr[parent] = t;

            //继续向下
            parent = child;
            child = parent * 2 + 1;
        }
        else 
        {
            break;
        }
    }
}

void heapSort(int* arr, int numsSize)
{
    //向下调整建堆
    //父结点 -- (numsSize-1 - 1)/2
    for(int i = (numsSize- 2) / 2; i >= 0; i-- )
    {
        adjustDown(arr, i, numsSize);
    }
    
    //建好堆 排序
    int end = numsSize-1;
    while(end > 0)
    {
        int t = arr[0];
        arr[0] = arr[end];
        arr[end] = t;

        adjustDown(arr, 0, end);
        end--;
    }
}

int findKthLargest(int* nums, int numsSize, int k) {
    heapSort(nums, numsSize);
    return nums[k-1];
}
```

