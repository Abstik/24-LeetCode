## [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) 

![image-20250509210404061](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250509210404061.png) 

```c
int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {
    //整体思路：运用了单调栈的思想，用栈存储数组索引，遍历nums2，得到一个数组result_num2第i个位置存储在nums2中比num[i]大的且在num[i]右边的数，可以知道nums1是nums2的一个子集,所以只需要遍历两个数组，当值相等时，把result_num2对应位置的值导入到结果数组即可。
    int* stack=calloc(nums2Size,sizeof(int));//分别创建栈，栈顶指针，存储num2相应更大值的数组，结果数组
    int top=-1;
    int* result_num2=calloc(nums2Size,sizeof(int));
    *returnSize=nums1Size;
    int* ans=calloc(nums1Size,sizeof(int));
    stack[++top]=0;//栈顶元素设置为0，之后从一开始遍历
    for(int i=0;i<nums2Size;i++){//全部设置为-1，假设没有更大的值，若有，之后直接赋值即可
        result_num2[i]=-1;
    }
    for(int i=1;i<nums2Size;i++){//从1开始遍历
        if(nums2[i]<=nums2[stack[top]]){//如果当前值小于等于栈顶值，则入栈，并将栈顶指针后移，说明该位置后一个值不比它大
            stack[++top]=i;
        }else{//如果大于栈顶值
            while((top>=0)&&(nums2[i]>nums2[stack[top]])){//如果栈内有值，且当前值比栈顶值大，设置更大的值到数组中
                result_num2[stack[top]]=nums2[i];
                top--;
            }
            stack[++top]=i;//添加索引以便下次寻找
        }
    }
    for(int i=0;i<nums1Size;i++){
        for(int j=0;j<nums2Size;j++){
            if(nums1[i]==nums2[j]){//找到相应位置
                ans[i]=result_num2[j];//设置结果数组为对应的值
            }
        }
    }
    return ans;
}
```

