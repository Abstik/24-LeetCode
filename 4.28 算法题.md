## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

![image-20250428120558029](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250428120558029.png)



```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	// 获取二维数组 obstacleGrid 的行数 m 和列数 n。
	// len(obstacleGrid) 得到行数，len(obstacleGrid[0]) 得到第一行的元素数量即列数
	m, n := len(obstacleGrid), len(obstacleGrid[0])

	// 创建二维数组 memory，用于存储中间结果/记忆化搜索，其大小和 obstacleGrid 相同
	memory := make([][]int, m)

	// 遍历 memory 数组的每一行
	for i := range memory {
		// 为每一行分配长度为 n 的内存
		memory[i] = make([]int, n)
		// 遍历当前行的每一个元素
		for j := range memory[i] {
			// 将每个元素初始化为 -1，表示该位置的结果还未计算过
			memory[i][j] = -1
		}
	}

	// 声明递归函数 dfs，计算从起点到 (i, j) 位置的路径数量
	var dfs func(int, int) int
	// 实现 dfs 函数
	dfs = func(i, j int) int {
		// 若当前位置越界，即行或列小于 0，或者是障碍物，即值为 1，则路径数量为 0
		if i < 0 || j < 0 || obstacleGrid[i][j] == 1 {
			return 0
		}
		// 若当前位置是起点 (0, 0)，则路径数量为 1
		if i == 0 && j == 0 {
			return 1
		}
		// 获取 memory 数组中 (i, j) 位置的指针
		p := &memory[i][j]
		// 若该位置的值为 -1，说明还未计算过
		if *p == -1 {
			// 递归计算从上方 (i - 1, j) 和左方 (i, j - 1) 到达当前位置的路径数量之和
			*p = dfs(i-1, j) + dfs(i, j-1)
		}
		// 返回 memory 数组中 (i, j) 位置存储的路径数量
		return *p
	}
	// 调用 dfs 函数计算从起点到终点 (m-1, n-1) 的路径数量
	return dfs(m-1, n-1)
}
```

