## [LCP 18. 早餐组合](https://leetcode.cn/problems/2vYnGI/) 

![image-20250425194310640](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250425194310640.png) 

```c
int cmp(const void* a, const void* b) { return (*(int*)a - *(int*)b); }//快速排序
int breakfastNumber(int* staple, int stapleSize, int* drinks, int drinksSize,int x) {
    //整体思路：运用双指针的思想，在将两个数组排序之后获取数组中符合要求的数，重新定义数组长度，前后指针分别从不同数组的不同方向开始遍历，降低时间复杂度。
    int i, j;
    int sum = 0;
    qsort(staple, stapleSize, sizeof(int), cmp);
    qsort(drinks, drinksSize, sizeof(int), cmp);
    for (i = 0; i < stapleSize; i++) {
        if (staple[i] > x) {
            stapleSize = i + 1;//遍历数组，直到找到大于预算的数，因为i从0开始，所以最后的数组长度定义为i+1
            break;
        }
    }
    for (i = 0; i < drinksSize; i++) {
        if (drinks[i] > x) {
            drinksSize = i + 1;
            break;
        }
    }
    j = drinksSize - 1;//在代码中，j = drinksSize - 1放在第二个for循环的外面（即第一个 for 循环之前）是为了利用双指针技巧的单调性，从而优化算法的时间复杂度。如果将它放在第二个for循环的括号里，会导致算法退化，失去优化效果。
    //j不会重置，而是随着i的增加单调递减（因为staple[i]增大，drinks[j]必须减小才能保持staple[i]+drinks[j]<= x）。
    for (i = 0; i < stapleSize; i++) {
        for (; j >= 0; j--) {
            if (staple[i] + drinks[j] <= x) {
                sum += j + 1;
                sum %= 1000000007;
                break;
            }
        }
    }
    return sum;
}
```

## [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) 

![image-20250425200230438](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250425200230438.png)

```c
void preOder(struct TreeNode* root,int* ret,int* returnSize){
    //前序遍历顺序：middle->left->right，运用递归遍历的思想
    if(root==NULL) return;
    ret[(*returnSize)++]=root->val;//先将根结点值录入
    preOder(root->left,ret,returnSize);//递归左，右节点
    preOder(root->right,ret,returnSize);
}
int* preorderTraversal(struct TreeNode* root, int* returnSize) {
    int* ret=(int*)calloc(100,sizeof(int));//分配内存
    *returnSize=0;//初始化数组大小
    preOder(root,ret,returnSize);//递归
    return ret;
}
```

