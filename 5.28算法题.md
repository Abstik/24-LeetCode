## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) 

![image-20250516213746264](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250516213746264.png) 

```go
func isSameTree(p,q *TreeNode) bool {
    //整体思路: 我们可以实现这样一个递归函数，通过同步移动两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。
    if p==nil || q==nil {// 如果 p 或 q 有一个是 nil
        return p==q		// 返回它们是否同时为 nil（即是否相同）
    }
    // 递归检查：
    // 1. 当前节点值是否相等
    // 2. p 的左子树是否和 q 的右子树相同（镜像对称的关键）
    // 3. p 的右子树是否和 q 的左子树相同（镜像对称的关键）
    return p.Val==q.Val&&isSameTree(p.Left,q.Right)&&isSameTree(p.Right,q.Left)
}
func isSymmetric(root *TreeNode) bool {
    return isSameTree(root.Left,root.Right)
}
```

