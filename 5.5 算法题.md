## [53. 最大子数组和 ](https://leetcode.cn/problems/maximum-subarray/submissions/627573233/)

![image-20250505195245264](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505051952611.png)

```C
//只要和为正，就向后找，正数越加越大
//和一旦为负数 就放弃 从下一个开始找

func maxSubArray(nums []int) int {
    max := nums[0]//先给最大值赋值
    count := 0

    for i:=0; i < len(nums); i ++ {
        count += nums[i]
        if count > max{  //更新max
            max = count
        }
        if count < 0{  //为0就从零开始向后找
            count = 0
        }
    }

    return max
}

```

## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/submissions/627576610/)

![image-20250505201053274](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505052010491.png)

```go
//直接上下坡
//平坡后上下坡 或者 上下坡后平坡也算
//单调里面平坡 不算

func wiggleMaxLength(nums []int) int {
    len := len(nums)
    if len < 2{
        return len
    }

    count := 1
    prevDiff := nums[1] - nums[0] //i - (i-1)
    if prevDiff != 0{  //如果开始两个元素不相等 那一定有两个元素符合要求
        count = 2
    }
    for i:=2; i<len; i++ {
        diff := nums[i] - nums[i-1]
        if diff > 0 && prevDiff <=0 || diff < 0 && prevDiff >= 0{ 
            count++
            prevDiff = diff //更新nums[i] - nums[i-1]
        }
    }
    return count
}

```

