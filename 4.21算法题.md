## [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/) 

![image-20250420210959901](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250420210959901.png) 

```c
char* removeDuplicates(char* s) {
    //基本思路，创建栈将字母导入，遍历字符串，如果当前字母与栈内的字母相同，出栈。
     int len=strlen(s);//获取字符串长度
     char* stack=(char*)calloc(len+1,sizeof(char));//创建栈
     int top=0;//用于栈
     int index=0;//用于遍历
     while(index<len){
        char letter=s[index++];//获取当前字母
        if(top>0&&letter==stack[top-1]){//如果栈内有元素并且当前字母与栈内字母相同，出栈，top-1是因为top指向下一个空位
            top--;
        }else stack[top++]=letter;//否则入栈
     }
     stack[top]='\0';//结束符
     return stack;//返回栈
}
```

## [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)  

![image-20250420211012825](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250420211012825.png) 

```c
int str_to_int(char* str){
//这个函数将字符串转换为整数：
//初始化num(结果)和tens(位权，初始为1)
//从字符串末尾向前遍历：如果遇到负号'-'，将结果取反并结束循环，如“-11”
//否则，将当前数字字符转换为数值，乘以对应位权后加到结果中
//由于是末尾向前遍历，所以每次循环位权乘以10,返回转换后的整数
    int num=0,tens=1;
    for(int i=strlen(str)-1;i>=0;i--){
        if(str[i]=='-'){
            num*=-1;
            break;
        }
        num+=(str[i]-'0')*tens;
        tens*=10;
    }
    return num;
}
//二级指针存储数字
int evalRPN(char** tokens, int tokensSize) {
    int *stack=(int*)malloc(tokensSize*sizeof(int));//为栈分配内存，大小为tokens数量乘以int大小
    int stacktop=0;
    for(int i=0;i<tokensSize;i++){
        char symbol=(tokens[i])[0];//这行代码的作用是获取当前token的第一个字符，用于判断该token是数字还是运算符。
//如果tokens[i]="+"，那么(tokens[i])[0]就是 '+'。
//如果tokens[i]="123"，那么(tokens[i])[0]就是 '1'。
        if(symbol<'0'&&(tokens[i])[1]=='\0'){//如果是运算符，即该字符的第二位为结束符
            int num1=stack[--stacktop];//获取前两个入栈的数字
            int num2=stack[--stacktop];
            int result;//根据符号计算结果
            if(symbol=='+'){ 
                result=num1+num2;
            }else if(symbol=='-'){
                result=num2-num1;
            }else if(symbol=='/'){
                result=num2/num1;
            }else{
                result=num1*num2;
            }
            stack[stacktop++]=result;
        }else{//如果是数字则入栈
            int num=str_to_int(tokens[i]);//字符转换为数字
            stack[stacktop++]=num;
        }
    }
    int result=stack[0];//最后留下来的唯一数字即为计算结果
    return result;
}
```

