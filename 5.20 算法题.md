## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

![image-20250520213047708](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505202130997.png)

```go
//f(i,j) 表示从左上角走到(i,j)的路径数量
//f(i,j) = f(i-1,j) + f(i,j-1) 注意不可以越界  --  考虑 i、j等于0的时候 
//f(0,0) = 1

func uniquePaths(m int, n int) int {
    dp := make([][]int, m)   //m行
    for i:=range dp {
        dp[i] = make([]int, n)  //每一行 n 列
        dp[i][0] = 1
    }

    for j:=0; j<n; j++ {
        dp[0][j] = 1
    }

    for i:=1; i<m; i++ {
        for j:=1; j<n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
}
```

## [63. 不同路径 II ](https://leetcode.cn/problems/unique-paths-ii/)

![image-20250520215247355](https://ting2.oss-cn-beijing.aliyuncs.com/picture/202505202152628.png)

```go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m,n := len(obstacleGrid), len(obstacleGrid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
        if obstacleGrid[i][0] == 1{  //是障碍物
            dp[i][0] = 0
        }else{
            if i > 0 && dp[i-1][0] == 0{    //不是第一列并且在第一行有障碍物
                dp[i][0] = 0
            }else{
                dp[i][0] = 1    //如果i=0，有障碍物，会在前面的if中执行；第一行其前面没有障碍物，为1
            }
        }
    }

    for j:=0; j<n; j++ {
        if obstacleGrid[0][j] == 1{
            dp[0][j] = 0
        }else{
            if j > 0 && dp[0][j-1] == 0{
                dp[0][j] = 0
            }else{
                dp[0][j] = 1
            }
        }
    }

    for i:=1; i<m; i++{
        for j:=1; j<n; j++{
            if obstacleGrid[i][j] == 1{
                dp[i][j] = 0
            }else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
}
```

