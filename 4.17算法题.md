## [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/) 

![image-20250417200512924](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250417200512924.png) 

```c
typedef struct {
    int stackintop,stackouttop;//两个指针stackInTop和stackOutTop，分别指向栈顶
    int stackin[100],stackout[100];
} MyQueue;


MyQueue* myQueueCreate() {
    MyQueue* queue=(MyQueue*)malloc(sizeof(MyQueue));//开辟一个队列的大小空间
    queue->stackintop=0;//将指针stackInTop和stackOutTop初始化为0
    queue->stackouttop=0;
    return queue;
}

void myQueuePush(MyQueue* obj, int x) {
    obj->stackin[(obj->stackintop)++]=x;//将元素存入第一个栈中,存入后栈顶指针+1
}

int myQueuePop(MyQueue* obj) {
    //1.若输出栈为空且当第一个栈中有元素（stackInTop>0时），将第一个栈中元素复制到第二个栈中（stackOut[stackTop2++] = stackIn[--stackTop1])
//2.将栈顶元素保存
//3.当stackTop2>0时，将第二个栈中元素复制到第一个栈中(stackIn[stackTop1++]=stackOut[--stackTop2])
    int stackintop=obj->stackintop;//复制栈顶指针，减少对内存的访问次数
    int stackouttop=obj->stackouttop;
    if(stackouttop==0){
        while(stackintop>0){
            obj->stackout[stackouttop++]=obj->stackin[--stackintop];
        }
    }
    ////将第二个栈中栈顶元素（队列的第一个元素）出栈，并保存
    int top=obj->stackout[--stackouttop];
    ////将输出栈中元素放回输入栈中
    while(stackouttop>0){
        obj->stackin[stackintop++]=obj->stackout[--stackouttop];
    }
    //更新栈顶指针
    obj->stackintop=stackintop;
    obj->stackouttop=stackouttop;
    //返回队列中第一个元素
    return top;
}
//返回输入栈中的栈底元素
int myQueuePeek(MyQueue* obj) {
    return obj->stackin[0];
}
//若栈顶指针均为0，则代表队列为空
bool myQueueEmpty(MyQueue* obj) {
    return obj->stackintop==0&&obj->stackouttop==0;
}
//将栈顶指针置0
void myQueueFree(MyQueue* obj) {
    obj->stackintop=0;
    obj->stackouttop=0;
}
```

## [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) 

![image-20250417200508890](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250417200508890.png) 

```c
typedef struct {
    int queue1[100],queue2[100];  // 两个数组模拟队列
    int front1,front2;            // 两个队列的头指针
    int rear1,rear2;              // 两个队列的尾指针
} MyStack;
MyStack* myStackCreate() {
    MyStack* stack=(MyStack*)malloc(sizeof(MyStack));  // 分配内存
    stack->front1=0;  // 初始化queue1的头指针
    stack->front2=0;  // 初始化queue2的头指针
    stack->rear1=0;   // 初始化queue1的尾指针
    stack->rear2=0;   // 初始化queue2的尾指针
    return stack;     // 返回创建的栈
}
void myStackPush(MyStack* obj, int x) {
    obj->queue1[obj->rear1++]=x;//将元素x添加到queue1的尾部
}
int myStackPop(MyStack* obj) {
    int front1=obj->front1,front2=obj->front2;  // 保存当前指针位置
    int rear1=obj->rear1,rear2=obj->rear2;
    // 将queue1中除最后一个元素外的所有元素转移到queue2
    while(rear1-front1>1){
        obj->queue2[rear2++]=obj->queue1[front1++];
    }
    int top=obj->queue1[front1++];  // 获取queue1的最后一个元素(栈顶)
    // 将queue2中的所有元素转移回queue1
    while(front2!=rear2){
        obj->queue1[rear1++]=obj->queue2[front2++];
    }
    // 更新指针位置
    obj->front1=front1,obj->front2=front2;
    obj->rear1=rear1,obj->rear2=rear2;
    return top;  // 返回栈顶元素
}
int myStackTop(MyStack* obj) {
    return obj->queue1[obj->rear1-1];// 返回queue1的最后一个元素
}
bool myStackEmpty(MyStack* obj) {
    return obj->rear1==obj->front1;// 如果queue1的头尾指针相同，则栈为空
}
void myStackFree(MyStack* obj) {
    obj->front1 = 0, obj->front2 = 0;// 重置指针
    obj->rear1 = 0, obj->rear2 = 0;
}
```

