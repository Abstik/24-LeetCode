## [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) 

![image-20250519215943733](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250519215943733.png) 

```go
//整体思路：dfs暴力匹配的方法，深度搜索root的每一个子树看是否与subRoot相等，分别做判断
func check (p,q *TreeNode) bool {//判断root的子树是否与subRoot相等
    if p==nil && q==nil {//如果都为空，说明此时root的一个路径已经搜索完成且与subRoot完全相同
        return true
    }
    if p==nil || q==nil {//否则不相同
        return false
    }
    if p.Val==q.Val {//如果一个节点值相等，说明搜索到subRoot的根节点，此时dfs左右子树看是否相等
        return check(p.Left,q.Left) && check(p.Right,q.Right)
    }
    return false 
}
func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    if root==nil {// 如果 root 为空，说明 root 已经遍历完毕且未找到匹配的子树，返回 false。
        return false
    }
    return check(root,subRoot) || isSubtree(root.Left,subRoot) || isSubtree(root.Right,subRoot)
    //当前 root 和 subRoot 完全相同（通过 check(root, subRoot) 判断）。
//subRoot 是 root.Left 的子树（通过 isSubtree(root.Left, subRoot) 递归判断）。
//subRoot 是 root.Right 的子树（通过 isSubtree(root.Right, subRoot) 递归判断）。
//如果其中任意一种情况为 true，则 subRoot 是 root 的子树，返回 true；否则返回 false。
}

```

