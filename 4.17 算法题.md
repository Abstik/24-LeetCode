## [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

![image-20250416183955063](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250416183955063.png)



```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    int num = 1; // 起始值
    int** matrix = (int**)malloc(sizeof(int*) * n); // 分配行内存
    *returnSize = n; // 返回值
    *returnColumnSizes = malloc(sizeof(int) * n); // 为解引用的数组分配内存
    for (int i = 0; i < n; i ++)
	{
        matrix[i] = (int*)malloc(sizeof(int) * n); // 分配列内存
        memset(matrix[i], 0, sizeof(int) * n); // 初始化置零
        (*returnColumnSizes)[i] = n; // 保留列数据
    }
    
    int left = 0, right = n - 1, top = 0, bottom = n - 1; // 初始边界
    while (left <= right && top <= bottom)
	{
        for (int column = left; column <= right; column ++) // 从左至右
		{
            matrix[top][column] = num;
            num ++;
        }
        for (int row = top + 1; row <= bottom; row ++) // 从上至下
		{
            matrix[row][right] = num;
            num ++;
        }
        if (left < right && top < bottom) // 未遍历完
		{
            for (int column = right - 1; column > left; column --) // 从右至左
			{
                matrix[bottom][column] = num;
                num ++;
            }
            for (int row = bottom; row > top; row --) // 从下至上
			{
                matrix[row][left] = num;
                num ++;
            }
        }
        // 边界更新
        left ++;
        right --;
        top ++;
        bottom --;
    }
    return matrix;
}
```



## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

![image-20250416185125532](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250416185125532.png)



```c
// 滑动窗口？
int minSubArrayLen(int target, int* nums, int numsSize) {
    int ans = 100010, sum = 0, left = 0;
    for (int right = 0; right < numsSize; right ++)
    { 
        // 枚举子数组右端点
        sum += nums[right];
        while (sum - nums[left] >= target)
        { 
            // 尽量缩小子数组长度
            sum -= nums[left]; 
            left ++; // 左端点右移
        }
        if (sum >= target)
        {
            ans = fmin(ans, right - left + 1);
        }
    }
    return ans <= numsSize ? ans : 0;
}
```



## [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

![image-20250416221442265](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250416221442265.png)



```c
struct ListNode* swapPairs(struct ListNode* head) {
    // 递归法 
	if (head == NULL || head->next == NULL)
	{
        return head;
    }
    struct ListNode* newHead = head->next;
    head->next = swapPairs(newHead->next); // 递归调用 
    newHead->next = head;
    return newHead;
//    迭代法 
//    struct ListNode dummyHead;
//    dummyHead.next = head;
//    struct ListNode* temp = &dummyHead;
//    while (temp->next != NULL && temp->next->next != NULL) {
//        struct ListNode* node1 = temp->next;
//        struct ListNode* node2 = temp->next->next;
//        temp->next = node2;
//        node1->next = node2->next;
//        node2->next = node1;
//        temp = node1;
//    }
//    return dummyHead.next;
}
```

