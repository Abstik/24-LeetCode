## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

![image-20250508134154198](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250508134154198.png)



```go
func wiggleMaxLength(nums []int) int {
    if len(nums) <= 1 { // 单元素特判
       return len(nums)
    }
    l, r := 0, 1 // 双指针
    b, s := 0, 0 // b 用于标记上一次是下降趋势，s 用于标记上一次是上升趋势
    cnt := 0
    // 当右指针小于数组长度，继续循环
    for r < len(nums) {
       num := nums[r] - nums[l] // 计算当前元素与前一个元素的差值
       if num < 0 && b == 0 {   // 差值小于0，且上一次不是下降趋势
          b = 1 // 标记为下降趋势
          cnt++
       } else if num > 0 && (b == 1 || s == 0) { // 差值大于0，且上一次是下降趋势或者上一次没有上升趋势
          b = 0 // 标记为非下降趋势
          s = 1 // 标记为上升趋势
          cnt++
       }
       // 维护序列
       l = r
       r++
    }
    return cnt + 1 // 首元素
}
```



## [2149. 按符号重排数组](https://leetcode.cn/problems/rearrange-array-elements-by-sign/)

![image-20250508140035424](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250508140035424.png)



```go
func rearrangeArray(nums []int) []int {
    // 归并
    length := len(nums)
    k, p, q := 0, 0, 0        // k作rt数组指针，p->正数, q->负数
    rt := make([]int, length) // 返回数组/切片
    for k < length && (p < length && q < length) {
       for ; nums[p] < 0; p++ { // 找到下一个正数
       }
       rt[k] = nums[p]
       k++
       p++
       for ; nums[q] > 0; q++ { //找到下一个负数
       }
       rt[k] = nums[q]
       k++
       q++
    }
    return rt
}
```