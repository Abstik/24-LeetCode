## [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/) 

![image-20250422165421511](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250422165421511.png) 

```c
int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize) {
    //基本思路：从后往前遍历温度数组，使用单调栈的思想
    *returnSize=temperaturesSize;
    int* ans=calloc(*returnSize,sizeof(int));//分配并初始化结果数组ans，使用calloc确保初始值为0
    int* stack=malloc((*returnSize)*sizeof(int));
    int top=-1;
    for(int i=temperaturesSize-1;i>=0;i--){//从后向前遍历温度数组
        int cur=temperatures[i];
        while(top>=0&&cur>=temperatures[stack[top]]){//维护单调栈：弹出栈顶所有温度小于等于当前温度的索引，保持栈中元素对应的温度是严格递减的
            top--;
        }
        if(top>=0){//如果栈不为空，栈顶元素就是第一个比当前温度高的日子
            ans[i]=stack[top]-i;
        }
        stack[++top]=i;//将当前索引入栈
    }
    return ans;
}
```

## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/) 

![image-20250422165425391](https://gggzxh.oss-cn-beijing.aliyuncs.com/img/20250422165425391.png) 

```c
struct ListNode* rotateRight(struct ListNode* head, int k) {
//如果k为0，不需要旋转
//如果链表为空或只有一个节点，旋转后结果不变
//直接返回原链表头
    if (k == 0 || head == NULL || head->next == NULL) {
        return head;
    }
    int num=1;//计数器，统计链表节点数（初始为1是因为从head开始）
    struct ListNode* newhead=head;//newhead指针指向head，用于遍历链表
    while(newhead->next){
        newhead=newhead->next;
        num++;
    }
//k%num：处理k大于链表长度的情况，取模得到有效旋转次数
//num-k%num：找到新的头节点应该在的位置（从尾部算起）
    int a=num-k%num;
    if(a==num) return head;//如果a等于链表长度，说明旋转后链表与原链表相同，直接返回原链表
    newhead->next=head;//将链表首尾相连形成环
    while(a--) newhead=newhead->next;//移动newhead指针到新的尾节点位置：
    head=newhead->next;//设置新的头节点：新头节点是新尾节点的下一个节点
    newhead->next=NULL;//新尾节点的next置为NULL
    return head;
}
```

